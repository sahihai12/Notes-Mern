---
id: js-theory-questions
title: Theory Questions
---

### Hoisting
> hositing is a phenomenon in js by which you can acess these var and function even before initialitation 
> Hoisting allows you to use functions and variables before they're declared. “Hoisting” refers to the process by which variable and function declarations are moved to the top of their respective scopes during the compilation phase, before the code is actually executed.


### **var vs let vs const – What's the Difference?**

* Scope of variable   
* Redeclaration and reassignment   
* Hoisting 

Variables declared with var are hoisted to the top of their global or local scope, which makes them accessible before the line they are declared. The number variable here has a global scope. Since it is declared with var, the variable is hoisted. This means that we can access the variable before the line where it was declared without errors.

var variables are hoisted with a default value of **undefined**, which makes them accessible before their line of declaration (as we've seen above).But, let variables are hoisted without a default initialization. So when you try to access such variables, instead of getting **undefined**, or a variable **is not defined** error, you cannot **access the variable before initialization**. You get an **reference error** when trying to access let and const before they are initialised.

**Undefined vs not-defined** : A variable that has been declared but not assigned a value is undefined. A variable that has not been declared at all is not defined

The reason that we get a reference error when we try to access a let or const variable before its declaration is because of the **temporal dead zone** (**TDZ**).

### Why Use finally Instead of Just Placing Code After catch?
- Reduced Duplication: Without finally, you would need to place cleanup code in both the try block (after successful execution) and the catch block (after handling errors). This leads to code duplication and increases the risk of missing one of the branches.

- Consistent Cleanup: If your try block has multiple return statements or code paths that could exit early, placing cleanup logic after catch may not cover all possible paths. finally ensures the cleanup code runs no matter where or how the try block exits.

- Clarity and Intent: Using finally indicates to other developers that this block of code should always be run as part of a cleanup operation. This improves code readability and conveys the intent clearly.

```js title="With Finally"
function performOperationWithoutFinally() {
    try {
        console.log("Trying to execute code...");
        // Simulate an error or simply return
        return 'sucess'
    } catch (error) {
        console.error("Caught an error:", error.message);
    }finally{
      console.log("Cleanup task with finally.");
    }
    // Code placed here will only run if the error is caught and execution continues
    console.log('this will not console')
}

performOperationWithoutFinally();
// This approach doesn't guarantee that the cleanup task runs if there is an early return or an unhandled error.
```


```js title="Without Finally Block"
function performOperationWithoutFinally() {
    try {
        console.log("Trying to execute code...");
        // Simulate an error
        return new Error("An error occurred!");
    } catch (error) {
        console.error("Caught an error:", error.message);
    }
    // Code placed here will only run if the error is caught and execution continues
    console.log("Cleanup task without finally."); // it will not execute
}

performOperationWithoutFinally();
// This approach doesn't guarantee that the cleanup task runs if there is an early return or an unhandled error.

```



### Why async/await Doesn't Work Well with forEach
> The issue arises because forEach is not aware about async and it does not return or handle the promises generated by await inside its callback. Therefore, the loop runs all iterations immediately without waiting for the asynchronous operations to complete.

```js 
const array = [
  { id: 1, delay: 1000 }, // Delay of 1 second
  { id: 2, delay: 2000 }, // Delay of 2 seconds
  { id: 3, delay: 1500 }, // Delay of 1.5 seconds
];

// Function that returns a promise which resolves after the specified delay
const logWithDelay = async item => {
  await new Promise(resolve => setTimeout(resolve, item.delay));
  console.log(`Logged item with id: ${item.id} after ${item.delay} ms`);
};

const processArray = async () => {
  array.forEach(async el => {
    await logWithDelay(item);
  });
 
  console.log('All items have been processed');
};

processArray();
```

```js title="we can use an alternate"

async function processArray() {
    for (const item of array) {
        await logWithDelay(item);
    }
    console.log("All items have been processed");
}

processArray();

```


### for-of vs for-in

```js title="For-in iterate over key/index"
const obj = { a: 1, b: 2, c: 3 };

for (const key in obj) {
    console.log(key); // Outputs: 'a', 'b', 'c'
    console.log(obj[key]); // Outputs: 1, 2, 3
}

const array = [10, 20, 30];
for (const index in array) {
    console.log(index); // Outputs: '0', '1', '2'
    console.log(array[index]); // Outputs: 10, 20, 30
}

```

```js title="For-of iterate over value"
const array = [10, 20, 30];

for (const value of array) {
    console.log(value); // Outputs: 10, 20, 30
}

const string = 'hello';
for (const char of string) {
    console.log(char); // Outputs: 'h', 'e', 'l', 'l', 'o'
}

```


### Shallow vs Deep copy 
- A shallow copy of an object or array creates a new object or array, but it only copies the references to the original nested objects or arrays found in the original structure. In other words, it creates a new instance of the top-level object or array, but the nested elements within it still reference the same objects or arrays as the original.
- A deep copy, on the other hand, creates a completely new object or array with all nested objects and arrays recursively copied. This means that every nested object or array is duplicated rather than being referenced. Therefore, modifications to the copied structure do not affect the original structure.


### Event Propagation 
> Event Propagation (determines in which order the elements receive the event).

1. **Event Capturing:**  
   * The event starts from the root element and travels down to the target element.  
   * This is the first phase of event propagation.  
2. **Event Target:**  
   * The event reaches the target element where the event was originally triggered.  
   * This is the second phase.  
3. **Event Bubbling:**  
   * The event starts from the target element and travels up to the root element.  
   * This is the third phase of event propagation.

event.stopPropagation() Stops the event from propagating further.  
**event.preventDefault()** method in JavaScript is used to prevent the default action that belongs to the event from being executed. This is particularly useful when you want to handle an event with custom logic instead of allowing the browser's default behaviour.

### Debouncing vs Throttling 
> <span style={{color: '#ff00a9'}}>Debouncing</span> ensures that a function is only called once after a certain period of time has passed since the last event. This means that if an event keeps occurring, the function will not execute until the events stop and the delay has passed.

Useful for scenarios like:
- Search input boxes: Only make an API call when the user has stopped typing for a certain period.
- Resize events: To run a function only when the resizing has stopped.

```js 
function debounce(func, delay) {
    let timeoutId;
    return function(...args) {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => {
            func.apply(this, args);
        }, delay);
    };
}

// Example usage
const log = () => console.log('Function executed after delay');
const debouncedLog = debounce(log, 1000);

window.addEventListener('resize', debouncedLog);
```

> <span style={{color: '#ff00a9'}}>Throttling</span> ensures that a function is called at regular intervals, no matter how many times an event is triggered. This limits the number of times the function can be executed over time.

Useful for scenarios like:
- Scroll events: Limit the number of times a function is called during scrolling.
- Button clicks: Prevent multiple rapid submissions by limiting how often the function runs.

```js 
function throttle(func, interval) {
    let lastTime = 0;
    return function(...args) {
        const now = Date.now();
        if (now - lastTime >= interval) {
            lastTime = now;
            func.apply(this, args);
        }
    };
}

// Example usage
const log = () => console.log('Function executed at regular intervals');
const throttledLog = throttle(log, 1000);

window.addEventListener('scroll', throttledLog);
```


### forEach vs map
forEach and map are both used to iterate over arrays, but they serve different purposes.
- forEach is used for executing side effects and doesn't return a new array.
- map is used when you need to transform an array and return a new array.

```js
const array = [1, 2, 3];
array.forEach((num) => {
    console.log(num * 2); // Logs: 2, 4, 6
});

const array = [1, 2, 3];
const doubled = array.map((num) => num * 2);
console.log(doubled); // Output: [2, 4, 6]

```


### Prototypal Inheritance
> Prototypal inheritance is a feature in JavaScript where objects can inherit properties and methods from other objects. Each object has an internal link ([[Prototype]]) to another object called its prototype.

Use Case: Allows you to share properties and methods across multiple instances without duplicating them.

```js
const parentObject = {
    greet: function() {
        console.log('Hello from parent!');
    }
};

const childObject = Object.create(parentObject);
childObject.greet(); // Output: 'Hello from parent!'

```


### map, filter, reduce

- map transforms each element and returns a new array.
- filter returns a subset of the original array.
- reduce aggregates the array elements into a single value.

```js 
const nums = [1, 2, 3];
const squares = nums.map((n) => n * n);
console.log(squares); // Output: [1, 4, 9]


const nums = [1, 2, 3, 4, 5];
const evenNums = nums.filter((n) => n % 2 === 0);
console.log(evenNums); // Output: [2, 4]


const nums = [1, 2, 3, 4];
const sum = nums.reduce((accumulator, currentValue) => accumulator + currentValue, 0);
console.log(sum); // Output: 10
```


### Object.seal vs Object.freeze
> Object.seal: Prevents new properties from being added to an object and marks all existing properties as non-configurable. However, you can still modify the values of existing properties.

```js 
const obj = { name: 'Alice' };
Object.seal(obj);
obj.age = 30; // Adding new property fails silently or throws an error in strict mode.
obj.name = 'Bob'; // This works; modifying properties is allowed.
```
> Object.freeze: Prevents new properties from being added to an object and also prevents existing properties from being modified or deleted.

```js
const obj = { name: 'Alice' };
Object.freeze(obj);
obj.name = 'Bob'; // This fails; modification is not allowed.
obj.age = 30; // This fails; adding new properties is not allowed.
```

### Object.entries

> Object.entries() is a method that returns an array of a given object's own enumerable property [key, value] pairs.
```js
const obj = { name: 'Alice', age: 25 };
const entries = Object.entries(obj);

for (const [key, value] of entries) {
    console.log(`${key}: ${value}`);
}
// Output:
// name: Alice
// age: 25

```

### Spread vs Rest Operator
> The spread operator is used to expand an iterable (like an array or a string) into its individual elements. It is commonly used in function calls, array literals, and object literals.

> The rest operator is used to collect multiple elements into a single array or object. It is typically used in function parameters to gather arguments into an array, or in destructuring assignments to collect the remaining elements.

### Polyfill 
> In JavaScript, a polyfill is a piece of code (usually JavaScript code) that provides the functionality that is not natively supported by a certain environment (e.g., a web browser). Polyfills are used to implement features that are part of modern standards (like ES6) in environments where these features are not yet available.


